"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extractSpecifiedFields = exports.generateConditionTree = exports.parseQuery = void 0;
const antlr4_1 = require("antlr4");
const condition_tree_query_walker_1 = __importDefault(require("./custom-parser/condition-tree-query-walker"));
const custom_query_parser_1 = __importDefault(require("./custom-parser/custom-query-parser"));
/**
 * All these classes are generated by antlr (the command line)
 * In order to support new syntax:
 * 1. Update the grammar file (src/parser/Query.g4)
 * 2. Run `yarn build:parser` to generate the new classes
 * 3. Manually update the parser to add `override` on the EOF line (needed by TS)
 *
 * The grammar syntax is documented here: https://www.antlr.org/
 * And can be tested online here: http://lab.antlr.org/
 */
const fields_query_walker_1 = __importDefault(require("./custom-parser/fields-query-walker"));
const QueryLexer_1 = __importDefault(require("./generated-parser/QueryLexer"));
function parseQuery(query) {
    const chars = new antlr4_1.CharStream(query?.trim()); // replace this with a FileStream as required
    const lexer = new QueryLexer_1.default(chars);
    const tokens = new antlr4_1.CommonTokenStream(lexer);
    const parser = new custom_query_parser_1.default(tokens);
    return parser.query();
}
exports.parseQuery = parseQuery;
function generateConditionTree(caller, tree, fields) {
    const walker = new condition_tree_query_walker_1.default(caller, fields);
    antlr4_1.ParseTreeWalker.DEFAULT.walk(walker, tree);
    const result = walker.conditionTree;
    if (result) {
        return result;
    }
    // Parsing error, fallback
    return walker.generateDefaultFilter(tree.getText());
}
exports.generateConditionTree = generateConditionTree;
function extractSpecifiedFields(tree) {
    const walker = new fields_query_walker_1.default();
    antlr4_1.ParseTreeWalker.DEFAULT.walk(walker, tree);
    return walker.fields;
}
exports.extractSpecifiedFields = extractSpecifiedFields;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UtcXVlcnkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZGVjb3JhdG9ycy9zZWFyY2gvcGFyc2UtcXVlcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQ0EsbUNBQXdFO0FBRXhFLDhHQUFtRjtBQUNuRiw4RkFBb0U7QUFDcEU7Ozs7Ozs7OztHQVNHO0FBQ0gsOEZBQW9FO0FBQ3BFLCtFQUF1RDtBQUd2RCxTQUFnQixVQUFVLENBQUMsS0FBYTtJQUN0QyxNQUFNLEtBQUssR0FBRyxJQUFJLG1CQUFVLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyw2Q0FBNkM7SUFDMUYsTUFBTSxLQUFLLEdBQUcsSUFBSSxvQkFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3BDLE1BQU0sTUFBTSxHQUFHLElBQUksMEJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUMsTUFBTSxNQUFNLEdBQUcsSUFBSSw2QkFBaUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUU3QyxPQUFPLE1BQU0sQ0FBQyxLQUFLLEVBQUUsQ0FBQztBQUN4QixDQUFDO0FBUEQsZ0NBT0M7QUFFRCxTQUFnQixxQkFBcUIsQ0FDbkMsTUFBYyxFQUNkLElBQWtCLEVBQ2xCLE1BQWdDO0lBRWhDLE1BQU0sTUFBTSxHQUFHLElBQUkscUNBQXdCLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBRTVELHdCQUFlLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFFM0MsTUFBTSxNQUFNLEdBQUcsTUFBTSxDQUFDLGFBQWEsQ0FBQztJQUVwQyxJQUFJLE1BQU0sRUFBRTtRQUNWLE9BQU8sTUFBTSxDQUFDO0tBQ2Y7SUFFRCwwQkFBMEI7SUFDMUIsT0FBTyxNQUFNLENBQUMscUJBQXFCLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUM7QUFDdEQsQ0FBQztBQWpCRCxzREFpQkM7QUFFRCxTQUFnQixzQkFBc0IsQ0FBQyxJQUFrQjtJQUN2RCxNQUFNLE1BQU0sR0FBRyxJQUFJLDZCQUFpQixFQUFFLENBQUM7SUFDdkMsd0JBQWUsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQztJQUUzQyxPQUFPLE1BQU0sQ0FBQyxNQUFNLENBQUM7QUFDdkIsQ0FBQztBQUxELHdEQUtDIn0=