"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const luxon_1 = require("luxon");
class ResultBuilder {
    value(value, previousValue) {
        return { countCurrent: value, countPrevious: previousValue };
    }
    distribution(obj) {
        return Object.entries(obj).map(([key, value]) => ({ key, value }));
    }
    /**
     * Add a TimeBasedChart based on a time range and a set of values.
     * @param {DateOperation} timeRange - The time range for the chart,
     * specified as "Year", "Month", "Week" or "Day".
     * @param {Array<{ date: Date; value: number | null }> | Record<string, number>} values -
     *  This can be an array of objects with 'date' and 'value' properties,
     *  or a record (object) with date-value pairs.
     *
     * @returns {TimeBasedChart} Returns a TimeBasedChart representing the data within the specified
     * time range.
     *
     * @example
     * timeBased(
     *  'Day',
     *   [
     *    { date: new Date('2023-01-01'), value: 42 },
     *    { date: new Date('2023-01-02'), value: 55 },
     *    { date: new Date('2023-01-03'), value: null },
     *   ]
     * );
     */
    timeBased(timeRange, values) {
        if (!values)
            return [];
        if (Array.isArray(values)) {
            return ResultBuilder.buildTimeBasedChartResult(timeRange, values);
        }
        const formattedValues = Object.entries(values).map(([stringDate, value]) => ({
            date: new Date(stringDate),
            value,
        }));
        return ResultBuilder.buildTimeBasedChartResult(timeRange, formattedValues);
    }
    /**
     * Add a MultipleTimeBasedChart based on a time range,
     * an array of dates, and multiple lines of data.
     *
     * @param {DateOperation} timeRange - The time range for the chart,
     * specified as "Year", "Month", "Week" or "Day".
     * @param {Date[]} dates - An array of dates that define the x-axis values for the chart.
     * @param {Array<{ label: string; values: Array<number | null> }>} lines - An array of lines,
     * each containing a label and an array of numeric data values (or null)
     * corresponding to the dates.
     *
     * @returns {MultipleTimeBasedChart} Returns a MultipleTimeBasedChart representing multiple
     * lines of data within the specified time range.
     *
     * @example
     * multipleTimeBased(
     *  'Day',
     *  [
     *    new Date('1985-10-26'),
     *    new Date('2011-10-05T14:48:00.000Z'),
     *    new Date()
     *  ],
     *  [
     *    { label: 'line1', values: [1, 2, 3] },
     *    { label: 'line2', values: [3, 4, null] }
     *  ],
     * );
     */
    multipleTimeBased(timeRange, dates, lines) {
        if (!dates || !lines)
            return { labels: null, values: null };
        let formattedTimes = null;
        const formattedLine = lines.map(line => {
            const values = dates.reduce((computed, date, index) => {
                computed.push({ date, value: line.values[index] });
                return computed;
            }, []);
            const buildTimeBased = ResultBuilder.buildTimeBasedChartResult(timeRange, values);
            if (!formattedTimes)
                formattedTimes = buildTimeBased.map(timeBased => timeBased.label);
            return { key: line.label, values: buildTimeBased.map(timeBased => timeBased.values.value) };
        });
        return {
            labels: formattedTimes,
            values: formattedTimes?.length > 0 ? formattedLine : null,
        };
    }
    percentage(value) {
        return value;
    }
    objective(value, objective) {
        return { value, objective };
    }
    leaderboard(obj) {
        return this.distribution(obj).sort((a, b) => b.value - a.value);
    }
    smart(data) {
        return data;
    }
    /*
     * Normalize the time based chart result to have a value for each time range.
     * For example, if the time range is 'Month' and the values are:
     * [
     *  // YYYY-MM-DD
     *  { date: new Date('2022-01-07'), value: 1 }, // Jan 22
     *  { date: new Date('2022-02-02'), value: 2 }, // Feb 22
     *  { date: new Date('2022-01-01'), value: 3 }, // Jan 22
     *  { date: new Date('2022-02-01'), value: 4 }, // Feb 22
     * ]
     * The result will be:
     * [
     *  { label: 'Jan 22', values: { value: 4 } },
     *  { label: 'Feb 22', values: { value: 6 } },
     * ]
     */
    static buildTimeBasedChartResult(timeRange, points) {
        if (!points.length)
            return [];
        const pointsInDateTime = points.map(point => ({
            date: luxon_1.DateTime.fromJSDate(point.date),
            value: point.value,
        }));
        const format = ResultBuilder.formats[timeRange];
        const formatted = {};
        pointsInDateTime.forEach(point => {
            const label = point.date.toFormat(format);
            if (typeof point.value === 'number')
                formatted[label] = (formatted[label] ?? 0) + point.value;
        });
        const dataPoints = [];
        const dates = pointsInDateTime
            .map(p => p.date)
            .sort((dateA, dateB) => dateA.toUnixInteger() - dateB.toUnixInteger());
        const first = dates[0].startOf(timeRange.toLowerCase());
        const last = dates[dates.length - 1];
        for (let current = first; current <= last; current = current.plus({ [timeRange]: 1 })) {
            const label = current.toFormat(format);
            dataPoints.push({ label, values: { value: formatted[label] ?? 0 } });
        }
        return dataPoints;
    }
}
exports.default = ResultBuilder;
ResultBuilder.formats = {
    Day: 'dd/MM/yyyy',
    Week: "'W'W-kkkk",
    Month: 'MMM yy',
    Year: 'yyyy',
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzdWx0LWJ1aWxkZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvZGVjb3JhdG9ycy9jaGFydC9yZXN1bHQtYnVpbGRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQVdBLGlDQUErQztBQUUvQyxNQUFxQixhQUFhO0lBUWhDLEtBQUssQ0FBQyxLQUFhLEVBQUUsYUFBc0I7UUFDekMsT0FBTyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxDQUFDO0lBQy9ELENBQUM7SUFFRCxZQUFZLENBQUMsR0FBMkI7UUFDdEMsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEVBQUUsR0FBRyxFQUFFLEtBQUssRUFBRSxDQUFDLENBQUMsQ0FBQztJQUNyRSxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O09Bb0JHO0lBQ0gsU0FBUyxDQUNQLFNBQXdCLEVBQ3hCLE1BQW1GO1FBRW5GLElBQUksQ0FBQyxNQUFNO1lBQUUsT0FBTyxFQUFFLENBQUM7UUFFdkIsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQ3pCLE9BQU8sYUFBYSxDQUFDLHlCQUF5QixDQUFDLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUNuRTtRQUVELE1BQU0sZUFBZSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxVQUFVLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUM7WUFDM0UsSUFBSSxFQUFFLElBQUksSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUMxQixLQUFLO1NBQ04sQ0FBQyxDQUFDLENBQUM7UUFFSixPQUFPLGFBQWEsQ0FBQyx5QkFBeUIsQ0FBQyxTQUFTLEVBQUUsZUFB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