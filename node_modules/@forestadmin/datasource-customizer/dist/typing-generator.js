"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const datasource_toolkit_1 = require("@forestadmin/datasource-toolkit");
const promises_1 = require("fs/promises");
class TypingGenerator {
    constructor(logger, options = {}) {
        this.logger = logger;
        this.options = {
            maxFieldsCount: 10000,
        };
        this.options.maxFieldsCount = options.maxFieldsCount ?? this.options.maxFieldsCount;
    }
    static sortedEntries(...args) {
        return Object.entries(...args).sort(([name1], [name2]) => name1.localeCompare(name2));
    }
    /**
     * Write types to disk at a given path.
     * This method read the file which is already there before overwriting so that customers
     * using equivalents to nodemon to not enter restart loops.
     */
    async updateTypesOnFileSystem(dataSource, typingsPath, typingsMaxDepth) {
        const newTypes = this.generateTypes(dataSource, typingsMaxDepth);
        let olderTypes = null;
        try {
            olderTypes = await (0, promises_1.readFile)(typingsPath, { encoding: 'utf-8' });
        }
        catch (e) {
            if (e.code === 'ENOENT')
                olderTypes = null;
            else
                throw e;
        }
        if (newTypes !== olderTypes) {
            await (0, promises_1.writeFile)(typingsPath, newTypes, { encoding: 'utf-8' });
        }
    }
    /**
     * Generates types on a string.
     */
    generateTypes(dataSource, maxDepth) {
        const collections = [...dataSource.collections].sort((a, b) => a.name.localeCompare(b.name));
        return [
            `/* eslint-disable */`,
            `import {`,
            `  CollectionCustomizer,`,
            `  TAggregation,`,
            `  TConditionTree,`,
            `  TPaginatedFilter,`,
            `  TPartialRow,`,
            `  TSortClause`,
            `} from '@forestadmin/agent';`,
            '',
            this.generateAliases(dataSource),
            '',
            'export type Schema = {',
            ...collections.map(collection => [
                `  '${collection.name}': {`,
                this.getRow(collection),
                this.getRelations(collection),
                this.getFlatRelations(collection, maxDepth),
                '  };',
            ].join(`\n`)),
            '};\n',
        ].join('\n');
    }
    generateAliases(dataSource) {
        return dataSource.collections
            .flatMap(collection => {
            const name = collection.name.slice(0, 1).toUpperCase() +
                collection.name.slice(1).replace(/(_|-)[a-z]/g, match => match.slice(1).toUpperCase());
            return [
                `export type ${name}Customizer = CollectionCustomizer<Schema, '${collection.name}'>;`,
                `export type ${name}Record = TPartialRow<Schema, '${collection.name}'>;`,
                `export type ${name}ConditionTree = TConditionTree<Schema, '${collection.name}'>;`,
                `export type ${name}Filter = TPaginatedFilter<Schema, '${collection.name}'>;`,
                `export type ${name}SortClause = TSortClause<Schema, '${collection.name}'>;`,
                `export type ${name}Aggregation = TAggregation<Schema, '${collection.name}'>;`,
                '',
            ];
        })
            .join('\n');
    }
    getRow(collection) {
        const content = TypingGenerator.sortedEntries(collection.schema.fields).reduce((memo, [name, field]) => {
            return field.type === 'Column'
                ? [...memo, `      '${name}': ${this.getStrictType(field)};`]
                : memo;
        }, []);
        return `    plain: {\n${content.join('\n')}\n    };`;
    }
    getRelations(collection) {
        const content = TypingGenerator.sortedEntries(collection.schema.fields).reduce((memo, [name, field]) => {
            if (field.type === 'ManyToOne' || field.type === 'OneToOne') {
                const relation = field.foreignCollection;
                return [
                    ...memo,
                    `      '${name}': Schema['${relation}']['plain'] & Schema['${relation}']['nested'];`,
                ];
            }
            return memo;
        }, []);
        return content.length ? `    nested: {\n${content.join('\n')}\n    };` : `    nested: {};`;
    }
    getFlatRelations(collection, maxDepth) {
        const fields = this.getFieldsOnCollection(collection, maxDepth);
        return fields.length
            ? `    flat: {\n      ${fields.join('\n      ')}\n    };`
            : `    flat: {};`;
    }
    getFieldsOnCollection(mainCollection, maxDepth) {
        const result = [];
        const queue = [{ collection: mainCollection, depth: 0, prefix: '', traversed: [] }];
        while (queue.length > 0 && result.length < this.options.maxFieldsCount) {
            const { collection, depth, prefix, traversed } = queue.shift();
            const sortedFields = TypingGenerator.sortedEntries(collection.schema.fields);
            if (prefix) {
                result.push(...sortedFields
                    .filter(([, schema]) => schema.type === 'Column')
                    .map(([name, schema]) => `'${prefix}:${name}': ${this.getStrictType(schema)};`));
            }
            if (depth < maxDepth) {
                queue.push(...sortedFields
                    .filter(([, schema]) => schema.type === 'ManyToOne' || schema.type === 'OneToOne')
                    .map(([name, schema]) => {
                    return {
                        subCollection: collection.dataSource.getCollection(schema.foreignCollection),
                        inverse: datasource_toolkit_1.CollectionUtils.getInverseRelation(collection, name),
                        name,
                        schema,
                    };
                })
                    .filter(({ subCollection, inverse }) => {
                    // Do not expand inverse relations, as those create useless cycles
                    return !traversed.find(({ c, r }) => c === subCollection && r === inverse);
                })
                    .map(({ subCollection, name }) => {
                    return {
                        collection: subCollection,
                        depth: depth + 1,
                        prefix: prefix ? `${prefix}:${name}` : name,
                        traversed: [...traversed, { c: collection, r: name }],
                    };
                }));
            }
        }
        if (queue.length || result.length >= this.options.maxFieldsCount) {
            this.logger?.('Warn', `Fields generation stopped on collection ${mainCollection.name}, ` +
                `try using a lower typingsMaxDepth (${maxDepth}) to avoid this issue.`);
        }
        return result.slice(0, this.options.maxFieldsCount);
    }
    getStrictType(columnSchema) {
        const isRequired = (columnSchema.validation?.some(v => v.operator === 'Present') ||
            columnSchema.isPrimaryKey ||
            columnSchema.allowNull === false) ??
            false;
        return `${this.getType(columnSchema)}${isRequired ? '' : ' | null'}`;
    }
    getType(field) {
        if (Array.isArray(field.columnType)) {
            return `Array<${this.getType({
                columnType: field.columnType[0],
                enumValues: field.enumValues,
            })}>`;
        }
        if (field.columnType === 'Enum') {
            if (field.enumValues === undefined)
                return 'string';
            return ([...field.enumValues]
                .sort((v1, v2) => v1.localeCompare(v2))
                .map(v => `'${v.replace(/'/g, "\\'")}'`)
                .join(' | ') ?? 'string');
        }
        if (typeof field.columnType === 'string') {
            return {
                Boolean: 'boolean',
                Binary: 'Buffer',
                Date: 'string',
                Dateonly: 'string',
                Json: 'any',
                Number: 'number',
                Point: '[number, number]',
                String: 'string',
                Time: 'string',
                Uuid: 'string',
            }[field.columnType];
        }
        return `{${TypingGenerator.sortedEntries(field.columnType)
            .map(([key, subType]) => `'${key}': ${this.getType({ columnType: subType })}`)
            .join('; ')}}`;
    }
}
exports.default = TypingGenerator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwaW5nLWdlbmVyYXRvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy90eXBpbmctZ2VuZXJhdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBRUEsd0VBTXlDO0FBQ3pDLDBDQUFrRDtBQUVsRCxNQUFxQixlQUFlO0lBS2xDLFlBQTZCLE1BQWMsRUFBRSxVQUF1QyxFQUFFO1FBQXpELFdBQU0sR0FBTixNQUFNLENBQVE7UUFKMUIsWUFBTyxHQUFHO1lBQ3pCLGNBQWMsRUFBRSxLQUFNO1NBQ3ZCLENBQUM7UUFHQSxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsR0FBRyxPQUFPLENBQUMsY0FBYyxJQUFJLElBQUksQ0FBQyxPQUFPLENBQUMsY0FBYyxDQUFDO0lBQ3RGLENBQUM7SUFFTyxNQUFNLENBQUMsYUFBYSxDQUMxQixHQUFHLElBQTBDO1FBRTdDLE9BQU8sTUFBTSxDQUFDLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3hGLENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksS0FBSyxDQUFDLHVCQUF1QixDQUNsQyxVQUFzQixFQUN0QixXQUFtQixFQUNuQixlQUF1QjtRQUV2QixNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLFVBQVUsRUFBRSxlQUFlLENBQUMsQ0FBQztRQUNqRSxJQUFJLFVBQVUsR0FBa0IsSUFBSSxDQUFDO1FBRXJDLElBQUk7WUFDRixVQUFVLEdBQUcsTUFBTSxJQUFBLG1CQUFRLEVBQUMsV0FBVyxFQUFFLEVBQUUsUUFBUSxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7U0FDakU7UUFBQyxPQUFPLENBQUMsRUFBRTtZQUNWLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxRQUFRO2dCQUFFLFVBQVUsR0FBRyxJQUFJLENBQUM7O2dCQUN0QyxNQUFNLENBQUMsQ0FBQztTQUNkO1FBRUQsSUFBSSxRQUFRLEtBQUssVUFBVSxFQUFFO1lBQzNCLE1BQU0sSUFBQSxvQkFBUyxFQUFDLFdBQVcsRUFBRSxRQUFRLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztTQUMvRDtJQUNILENBQUM7SUFFRDs7T0FFRztJQUNJLGFBQWEsQ0FBQyxVQUFzQixFQUFFLFFBQWdCO1FBQzNELE1BQU0sV0FBVyxHQUFHLENBQUMsR0FBRyxVQUFVLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFN0YsT0FBTztZQUNMLHNCQUFzQjtZQUN0QixVQUFVO1lBQ1YseUJBQXlCO1lBQ3pCLGlCQUFpQjtZQUNqQixtQkFBbUI7WUFDbkIscUJBQXFCO1lBQ3JCLGdCQUFnQjtZQUNoQixlQUFlO1lBQ2YsOEJBQThCO1lBQzlCLEVBQUU7WUFDRixJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQztZQUNoQyxFQUFFO1lBQ0Ysd0JBQXdCO1lBQ3hCLEdBQUcsV0FBVyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsRUFBRSxDQUM5QjtnQkFDRSxNQUFNLFVBQVUsQ0FBQyxJQUFJLE1BQU07Z0JBQzNCLElBQUksQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDO2dCQUN2QixJQUFJLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQztnQkFDN0IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLFVBQVUsRUFBRSxRQUFRLENBQUM7Z0JBQzNDLE1BQU07YUFDUCxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FDYjtZQUNELE1BQU07U0FDUCxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNmLENBQUM7SUFFTyxlQUFlLENBQUMsVUFBc0I7UUFDNUMsT0FBTyxVQUFVLENBQUMsV0FBVzthQUMxQixPQUFPLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDcEIsTUFBTSxJQUFJLEdBQ1IsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRTtnQkFDekMsVUFBVSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztZQUV6RixPQUFPO2dCQUNMLGVBQWUsSUFBSSw4Q0FBOEMsVUFBVSxDQUFDLElBQUksS0FBSztnQkFDckYsZUFBZSxJQUFJLGlDQUFpQyxVQUFVLENBQUMsSUFBSSxLQUFLO2dCQUN4RSxlQUFlLElBQUksMkNBQTJDLFVBQVUsQ0FBQyxJQUFJLEtBQUs7Z0JBQ2xGLGVBQWUsSUFBSSxzQ0FBc0MsVUFBVSxDQUFDLElBQUksS0FBSztnQkFDN0UsZUFBZSxJQUFJLHFDQUFxQyxVQUFVLENBQUMsSUFBSSxLQUFLO2dCQUM1RSxlQUFlLElBQUksdUNBQXVDLFVBQVUsQ0FBQyxJQUFJLEtBQUs7Z0JBQzlFLEVBQUU7YUFDSCxDQUFDO1FBQ0osQ0FBQyxDQUFDO2FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hCLENBQUM7SUFFTyxNQUFNLENBQUMsVUFBc0I7UUFDbkMsTUFBTSxPQUFPLEdBQUcsZUFBZSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FDNUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUN0QixPQUFPLEtBQUssQ0FBQyxJQUFJLEtBQUssUUFBUTtnQkFDNUIsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLEVBQUUsVUFBVSxJQUFJLE1BQU0sSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDO2dCQUM3RCxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQ1gsQ0FBQyxFQUNELEVBQUUsQ0FDSCxDQUFDO1FBRUYsT0FBTyxpQkFBaUIsT0FBTyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQ3ZELENBQUM7SUFFTyxZQUFZLENBQUMsVUFBc0I7UUFDekMsTUFBTSxPQUFPLEdBQUcsZUFBZSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLE1BQU0sQ0FDNUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEVBQUUsRUFBRTtZQUN0QixJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssV0FBVyxJQUFJLEtBQUssQ0FBQyxJQUFJLEtBQUssVUFBVSxFQUFFO2dCQUMzRCxNQUFNLFFBQVEsR0FBRyxLQUFLLENBQUMsaUJBQWlCLENBQUM7Z0JBRXpDLE9BQU87b0JBQ0wsR0FBRyxJQUFJO29CQUNQLFVBQVUsSUFBSSxjQUFjLFFBQVEseUJBQXlCLFFBQVEsZUFBZTtpQkFDckYsQ0FBQzthQUNIO1lBRUQsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLEVBQ0QsRUFBRSxDQUNILENBQUM7UUFFRixPQUFPLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLGtCQUFrQixPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDO0lBQzdGLENBQUM7SUFFTyxnQkFBZ0IsQ0FBQyxVQUFzQixFQUFFLFFBQWdCO1FBQy9ELE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxVQUFVLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFFaEUsT0FBTyxNQUFNLENBQUMsTUFBTTtZQUNsQixDQUFDLENBQUMsc0JBQXNCLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVU7WUFDekQsQ0FBQyxDQUFDLGVBQWUsQ0FBQztJQUN0QixDQUFDO0lBRU8scUJBQXFCLENBQUMsY0FBMEIsRUFBRSxRQUFnQjtRQUN4RSxNQUFNLE1BQU0sR0FBYSxFQUFFLENBQUM7UUFFNUIsTUFBTSxLQUFLLEdBQUcsQ0FBQyxFQUFFLFVBQVUsRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxNQUFNLEVBQUUsRUFBRSxFQUFFLFNBQVMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRXBGLE9BQU8sS0FBSyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksTUFBTSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLGNBQWMsRUFBRTtZQUN0RSxNQUFNLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLEdBQUcsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQy9ELE1BQU0sWUFBWSxHQUFHLGVBQWUsQ0FBQyxhQUFhLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUU3RSxJQUFJLE1BQU0sRUFBRTtnQkFDVixNQUFNLENBQUMsSUFBSSxDQUNULEdBQUcsWUFBWTtxQkFDWixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsTUFBTSxDQUFDLEVBQUUsRUFBRSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssUUFBUSxDQUFDO3FCQUNoRCxHQUFHLENBQ0YsQ0FBQyxDQUFDLElBQUksRUFBRSxNQUFNLENBQUMsRUFBRSxFQUFFLENBQ2pCLElBQUksTUFBTSxJQUFJLElBQUksTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQXNCLENBQUMsR0FBRyxDQUN4RSxDQUNKLENBQUM7YUFDSDtZQUVELElBQUksS0FBSyxHQUFHLFFBQVEsRUFBRTtnQkFDcEIsS0FBSyxDQUFDLElBQUksQ0FDUixHQUFHLFlBQVk7cUJBQ1osTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLE1BQU0sQ0FBQyxFQUFFLEVBQUUsQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLFdBQVcsSUFBSSxNQUFNLENBQUMsSUFBSSxLQUFLLFVBQVUsQ0FBQztxQkFDakYsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLEVBQUUsTUFBTSxDQUEyRCxFQUFFLEVBQUU7b0JBQ2hGLE9BQU87d0JBQ0wsYUFBYSxFQUFFLFVBQVUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQzt3QkFDNUUsT0FBTyxFQUFFLG9DQUFlLENBQUMsa0JBQWtCLENBQUMsVUFBVSxFQUFFLElBQUksQ0FBQzt3QkFDN0QsSUFBSTt3QkFDSixNQUFNO3FCQUNQLENBQUM7Z0JBQ0osQ0FBQyxDQUFDO3FCQUNELE1BQU0sQ0FBQyxDQUFDLEVBQUUsYUFBYSxFQUFFLE9BQU8sRUFBRSxFQUFFLEVBQUU7b0JBQ3JDLGtFQUFrRTtvQkFDbEUsT0FBTyxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLGFBQWEsSUFBSSxDQUFDLEtBQUssT0FBTyxDQUFDLENBQUM7Z0JBQzdFLENBQUMsQ0FBQztxQkFDRCxHQUFHLENBQUMsQ0FBQyxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFO29CQUMvQixPQUFPO3dCQUNMLFVBQVUsRUFBRSxhQUFhO3dCQUN6QixLQUFLLEVBQUUsS0FBSyxHQUFHLENBQUM7d0JBQ2hCLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsTUFBTSxJQUFJLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJO3dCQUMzQyxTQUFTLEVBQUUsQ0FBQyxHQUFHLFNBQVMsRUFBRSxFQUFFLENBQUMsRUFBRSxVQUFVLEVBQUUsQ0FBQyxFQUFFLElBQUksRUFBRSxDQUFDO3FCQUN0RCxDQUFDO2dCQUNKLENBQUMsQ0FBQyxDQUNMLENBQUM7YUFDSDtTQUNGO1FBRUQsSUFBSSxLQUFLLENBQUMsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLEVBQUU7WUFDaEUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUNYLE1BQU0sRUFDTiwyQ0FBMkMsY0FBYyxDQUFDLElBQUksSUFBSTtnQkFDaEUsc0NBQXNDLFFBQVEsd0JBQXdCLENBQ3pFLENBQUM7U0FDSDtRQUVELE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRU8sYUFBYSxDQUFDLFlBQTBCO1FBQzlDLE1BQU0sVUFBVSxHQUNkLENBQUMsWUFBWSxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsUUFBUSxLQUFLLFNBQVMsQ0FBQztZQUMzRCxZQUFZLENBQUMsWUFBWTtZQUN6QixZQUFZLENBQUMsU0FBUyxLQUFLLEtBQUssQ0FBQztZQUNuQyxLQUFLLENBQUM7UUFFUixPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxZQUFZLENBQUMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7SUFDdkUsQ0FBQztJQUVPLE9BQU8sQ0FBQyxLQUF3RDtRQUN0RSxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ25DLE9BQU8sU0FBUyxJQUFJLENBQUMsT0FBTyxDQUFDO2dCQUMzQixVQUFVLEVBQUUsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7Z0JBQy9CLFVBQVUsRUFBRSxLQUFLLENBQUMsVUFBVTthQUM3QixDQUFDLEdBQUcsQ0FBQztTQUNQO1FBRUQsSUFBSSxLQUFLLENBQUMsVUFBVSxLQUFLLE1BQU0sRUFBRTtZQUMvQixJQUFJLEtBQUssQ0FBQyxVQUFVLEtBQUssU0FBUztnQkFBRSxPQUFPLFFBQVEsQ0FBQztZQUVwRCxPQUFPLENBQ0wsQ0FBQyxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUM7aUJBQ2xCLElBQUksQ0FBQyxDQUFDLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsQ0FBQyxhQUFhLENBQUMsRUFBRSxDQUFDLENBQUM7aUJBQ3RDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxJQUFJLEVBQUUsS0FBSyxDQUFDLEdBQUcsQ0FBQztpQkFDdkMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLFFBQVEsQ0FDM0IsQ0FBQztTQUNIO1FBRUQsSUFBSSxPQUFPLEtBQUssQ0FBQyxVQUFVLEtBQUssUUFBUSxFQUFFO1lBQ3hDLE9BQU87Z0JBQ0wsT0FBTyxFQUFFLFNBQVM7Z0JBQ2xCLE1BQU0sRUFBRSxRQUFRO2dCQUNoQixJQUFJLEVBQUUsUUFBUTtnQkFDZCxRQUFRLEVBQUUsUUFBUTtnQkFDbEIsSUFBSSxFQUFFLEtBQUs7Z0JBQ1gsTUFBTSxFQUFFLFFBQVE7Z0JBQ2hCLEtBQUssRUFBRSxrQkFBa0I7Z0JBQ3pCLE1BQU0sRUFBRSxRQUFRO2dCQUNoQixJQUFJLEVBQUUsUUFBUTtnQkFDZCxJQUFJLEVBQUUsUUFBUTthQUNmLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxDQUFDO1NBQ3JCO1FBRUQsT0FBTyxJQUFJLGVBQWUsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQzthQUN2RCxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxHQUFHLE1BQU0sSUFBSSxDQUFDLE9BQU8sQ0FBQyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsQ0FBQyxFQUFFLENBQUM7YUFDN0UsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUM7SUFDbkIsQ0FBQztDQUNGO0FBalBELGtDQWlQQyJ9